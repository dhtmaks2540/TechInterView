# CustomView

* 기존에 있는 View (ImageView, TextView 등) 으로 표현할 수 없는 모양의 View를 구현해야 할때 필요하다. View를 상속받는 자손 클래스를 만들어서 구현한다.
* 구현 방법
    1. API에서 제공하는 기존 View를 상속해서 해당 View를 약간 변형시킨 View
    2. 기존 API에 전혀 존재하지 않는 뷰는 최상위 클래스인 View를 상속받아 메서드를 오버라이드. 즉, onDraw(), onMeasure(), onKeyDown()과 같이 시작하는 키워드가 ‘on’인 수퍼 클래스 메서드를 오버라이드
        * onDraw():
            * 뷰를 실제로 그릴때 사용
            * Canvas 객체를 매개변수로 받음
                * Canvas 객체는 어떤 도형을 그릴지 설정
                * Paint 객체는 도형의 색, 스타일, 글꼴 등을 설정
        * protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
            * 뷰의 크기를 설정할 때 사용
    3. 여러 뷰를 합쳐서 한번에 출력하기 위한 뷰(여러 뷰가 결합된 형태가 반복되서 사용될 때)
        * ViewGroup이나 LinearLayout 같은 Layout 클래스를 상속받아 작성

<br/>

# 컴포넌트

Android 앱은 컴포넌트로 구성되어 있는데 Activity, Service, Broadcast Receiver, Content Provider 이를 4대 컴포넌트라고 부른다. 각 컴포넌트는 하나의 독립된 형태로 존재하며, 정해진 역할을 수행한다. 참고로 컴포넌트는 앱의 구성 단위로 컴포넌트를 조합하여 하나의 앱을 만드는 것을 의미한다.

<br/>

# Activity

화면에 UI를 표시하는 기본요소. 대부분의 경우 액티비티는 꽉찬 화면을 구성하지만, 예외적으로 floating windows, multi-window mode 처럼 화면의 일부를 차지하게 할수 있다.

Acitivty 의 종류 중 하나로 FragmentActivity가 있는데, 이는 nested fragment, 즉 fragment 안에 다른 fragment가 있는 경우 고려할만 하다.

AppCompatActivity는 안드로이드 하위버전의 안드로이드를 지원하기 위해 사용된다. 참고로 AppCompatActivity는 FragmentActivity를 상속한다.

<br/>

## Activity Life Cycle

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa48a7350-eb06-4f33-8ddc-96e6e8ab5286%2F_2021-03-16__11.42.38.png?table=block&id=f61a6c9c-209e-42f0-bfde-8187148ee1f9&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=850&userId=&cache=v2)

액티비티의 상태는 크게 3가지로 나눌 수 있다.

* 활성 상태(create, start, resume)
* 일시정지 (pause)
* 멈춤 (stop, destroy)

액티비티는 각각의 상태에 따른 콜백 메소드들이 존재하는데, 일반적으로 순서는

* onCreate()
    * 이 함수는 필수적으로 구현해야한다.
    * 전체 LifeCycle 동안 "한 번"만 발생한다.
    * 이 메서드에는 XML, 멤버 변수 정의, 일부 UI구성 등 설정을 한다.
    
* onStart()
    * 활성상태에 들어가면 이 함수가 호출된다. (사용자한테 보여지기 직전)
    * 호출되면 포그라운드에 보내 상호작용을 할 수 있도록 준비한다.
    * 주로 UI를 관리하는 코드를 초기화 한다. 이 메서드는 매우 빠르게 완료되고 바로 onResume을 호출한다.
    
* onResume()
    * 사용자한테 화면에 보여지고 상호작용하는 메서드이다.
    * 어떤 이벤트가 발생하여 앱에서 포커스가 떠날 때까지 이 상태에 머무른다.
    * 이 상태에서는 생명주기 구성요소가 포그라운드에서 사용자에게 보이는 동안 실행해야 하는 모든 기능을 활성화 한다. (예: 카메라 미리보기)
    * 방해가 되는 이벤트가 발생하면 일시중지 상태에 들어가고, 시스템이 onPause()를 호출한다. (예: 전화가 오거나, 사용자가 다른 화면으로 이동하거나, 기기 화면이 off될 때)
    
* onPause() 
    * 사용자가 화면을 떠날 때 시스템이 첫 번째로 이 메서드를 호출한다. (상태가 포그라운드에 있지 않게 되었다는 것을 나타냄)
    * 포그라운드에 있지 않을 때 실행할 필요가 없는 기능을 모두 정지할 수 있다. (예: 카메라 미리보기 정지)
    * 시스템 리소스, 센서 핸들(GPS), 사용자가 필요로 하지 않을 때 배터리 수명에 영향을 미칠 수 있는 모든 리소스를 해제할 수도 있다. (UI 관련 리소스와 작업을 완전히 해제하거나 조정할 때는 onPause보다 onStop을 사용하는 것이 좋다. 멀티윈도우 모드 or 화면분할 때문)
    * 이 메서드는 아주 잠깐 실행되므로 저장 작업을 하기에는 시작이 부족할 수 있다. 사용자 데이터를 저장하거나, 네트워크를 호출하거나, 데이터베이스 트랜잭션을 실행해서는 안된다. 이 메서드가 끝나기 전에 완료하지 못할 수 있다. 무거운 작업을 onStop에서 하고 데이터 저장은 viewModel, onSaveInstanceState()를 참조.
    
    > 일반적인 다이얼로그는 activity가 아니기 때문에 onPause()를 호출하지 않는다. 권한요청은 다이얼로그 처럼 보이는 ui일뿐 실제로 동작은 권한을 허용할 것인지 거절할 것인지에 대한 ui를 띄우므로 onPause()를 호출한다.
    
* onStop()
    
    * 포커스가 완전히 빠졌을 때 시스템은 이 콜백 메서드를 호출한다. (화면전체가 가려졌을 때 또는 백그라운드로 갔을 때)
    * 이 메서드에서는 앱이 사용자에게 보이지 않는 동안 앱이 필요하지 않는 리소스를 해제하거나 조정해야 한다. (예: 애니메이션 중지, 세밀한 위치 업데이트에서 대략적인 위치 업데이트로 전환할 수 있다)
    * onStop()에서 무거운 작업을 실행해야 한다고 했는데 예를들어 정보를 데이터베이스에 저장해야하는데 적절한 위치를 찾지 못했다면 이 메서드에서 저장할 수 있다. (하지만 이 함수는 항상 호출되는 것은 아니며 메모리가 부족할 경우 호출이 안될 수도 있다)
    

* onDestroy()
    * Activity가 소멸되기 전에 호출된다. 시스템은 다음 중 하나에 해당할 때 이 콜백을 호출한다.
        1. 활동이 종료되는 경우 (스택에서 날리거나 finish()를 호출)
        2. 구성 변경(예: 기기회전 또는 멀티 윈도우모드)으로 인해 시스템이 일시적으로 활동을 소멸시키는 경우
    * onStop()에서 해제하지 않은 모든 리소스를 해제해야 한다.
    * 이 메서드가 호출되는 경우 시스템이 즉시 인스턴스를 생성한 다음, 새로운 구성에서 인스턴스에 관해 onCrate()를 호출한다.  
* onRestart()
    * onStop()상태에 있던 화면이 다시 접근 했을 때 호출되는 콜백함수

<br/>

### 액티비티에서 액티비티로 이동할 때 LifeCycle 순서

1. 액티비티에서 문자가 왔을 경우(화면이 일부 가려졌을 때)

onCreate() ~ onResume() -> 문자옴 -> onPause() -> 문자사라짐 -> onResume()

2. A 액티비티에서 B 액티비티로 이동

A onCreate() ~ onResume() -> 화면이동 클릭 -> A onPuase() -> B onCreate() ~ onResume() -> A onStop() .. onDestroy() (상황에 따라)

3. 액티비티에서 백그라운드로 갔다 다시 포그라운드로 복귀 시

onCreate() ~ onReume() -> 홈버튼(백그라운드) -> onPause() -> onStop() -> 앱 복귀 -> onRestart() -> onStart() -> onResume()

<br/>

### Activity에서 configuration changes가 될 때 LifeCycle 순서

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faa3d6c43-d00b-4646-a18f-174687d86a76%2F_2021-03-18__6.05.52.png?table=block&id=750a3e7a-cf1f-483a-a45b-2a9b663c40db&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=640&userId=&cache=v2)

<br/>

여기서 주목할 점은 사용자가 홈버튼을 누르거나 다른 액티비티가 화면을 차지했을 때 onPause() -> onStop 상태가 되는데, 이때 액티비티의 상태는 메모리에 보관되게 되며, 기기의 RAM 멤리가 부족하게 되면 시스템의 판단에 따라 액티비티는 destroy 된다.

또, 안드로이드에서는 액티비티의 configuration이 바뀌면 (화면 회전이나 멀티 윈도우 모드로 전환 같은 경우) 액티비티가 완전히 소멸 (destroy) 된후 재시작하게 되는데, 이때 액티비티의 상태를 보존하기 위해 사용되는게 onSaveInstanceState, onRestroeInstanceState, onCreate(Bundle) 이다.

<br/>

# Fragment

프래그먼트는 액티비티의 부분을 동적으로 동작시키기 위해 생긴 개념이다. 쉽게 비유를 들어 설명하자면, 앱하나를 서랍이라고 하고 액티비티를 서랍의 한칸이라고 하면, 프래그먼트는 서랍안의 부분부분을 나눠서 정리하는 정리함의 한 칸이라고 생각하면 된다.

프래그먼트를 사용하는 대표적인 예로 탭레이아웃이 있는데, 탭을 눌러서 다른화면으로 전환하는 앱의 경우이다. 이때 한 액티비티안에서 탭을 눌렀을 때 보여지는 프래그먼트만 바꾸게 되는데, 프래그먼트는 액티비티와 달리 스택에 쌓이지 않기 때문에 백버튼을 누른다고 해서 이전 프래그먼트로 돌아가지 않는다. 만약 어떤 이유로 프래그먼트를 스택에 넣고 싶다면 개발자가 직접 backStack에 추가해주는 방법도 있다.

<br/>

## Fragment 생명주기

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F954e40e8-e5a9-468f-ae02-1c2445380f09%2F_2021-03-16__3.22.27.png?table=block&id=48dee9e4-2401-47b1-b333-48802997ad3a&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=680&userId=&cache=v2)

* onAttach(Activity)   
    * 액티비티에서 프래그먼트가 호출될 때 최초 한번 호출되는 함수
* onCreate(Bundle)   
    * 프래그먼트가 생성될 떄 호출되는 함수   
* onCreateView(LayoutInflater, ViewGroup, Bundle)
    * 프래그먼트의 뷰를 생성하는 함수   
* onActivityCreated(Bundle)
    * 액티비티에서 onCreate()가 호출 된 프래그먼트에서 호출되는 함수 
* onStart()   
    * 프래그먼트가 사용자한테 보여지기 직전 호출되는 함수 
* onResume()
    * 프래그먼트가 사용자와 상호작용할 수 있는 상태  
* onPasue()   
    * 화면이 일부 가려졌을 때 호출
* onStop()  
    * 프래그먼트가 화면에 사라졌을 때 호출  
* onDestroyView() 
    * 프래그먼트의 View가 사라질때 호출되는 함수 
* onDestroy()
    * 프래그먼트가 제거될 때 호출되는 함수
* onDetach()  
    * 프래그먼트가 액티비티와 연결이 종료될 때 호출되는 함수

액티비티와 생명주기가 거의 비슷한데, onAttach, onCreateView, onDestroyView, onDetach라는 콜백이 추가된다. onCreateView에서 프래그먼트에 맞는 UI Layout을 리턴한다.

<br/>

## Fragment Manager

* 프래그먼트를 추가, 삭제 또는 교체하고 백스택에 추가하는 등의 작업을 실행하는 클래스
* 프래그먼트의 변경사항 집합을 트랜잭션이라고 한다.

## Fragment Transaction

* 각 트랜잭션은 수행하고자 하는 변경사항의 집합이다. 변성사항을 설정하려면 add(), remove(), replace()와 같은 메서드를 사용해야 한다.

<br/>

# Activity와 Fragment의 차이점

1. 액티비티는 독립적으로 활용할 수 있다.
2. 프래그먼트는 액티비티에 종속되어 있다.
3. 액티비티는 전체화면을 차지하지만 프래그먼트는 전체 화면이 아니여도 되며 디자인에 많은 유연성을 가지고 있다.
4. 액티비티는 자동적으로 백스택에 넣어지고 프래그먼트는 트랜잭션을 통해서 요청해야 한다.

<br/>

# BroadcastReceiver

안드로이드의 구성요소 중 하나로 원하는 메시지를 보내거나 받을 수 있는 컴포넌트이다. 예를 들면, 충전기를 꼽았다던지, SMS문자메시지, 전화가 온다거나 하는 일에 대한 메세지를 받을 수 있다. sendBroadCast() 라는 메소드를 통해 메세지를 보내면 리시버에서 메세지를 받을 수 있다.

BroadCastReceiver를 등록하는 방법은 크게 두가지가 있다. 첫번째로 정적으로 등록하는 방법인데, AndroidManifest 파일에 리시버라는 태그를 이용해서 추가하는 방법이다. 이 방법을 사용하면 앱이 실행중이지 않을때도 메세지를 받을 수 있다.

두번째 방법으로 동적 등록은 액티비티의 Context를 통해 등록한다. Context의 registerReceiver() 메소드를 통해 등록할 수 있는데, 이렇게 등록하게 되면 액티비티가 destroy되기 전까지만 메세지를 받을 수 있다. unRegisterReceiver()를 통해 리시버가 더 이상 필요하지 않을때 해제시킬 수 있다.

#### 메시지를 보내는 방법

sendOrderBroadcast() 는 한번에 한 수신자에게만 메세지를 전달한다. BroadcastReceiver를 따라 전파됨에 따라 다음 수신자에게 계속 메세지를 전달할수도, 또는 차단할수도 있다.
sendBroadcast()는 모든 수신자에게 메세지를 전파한다.
LocalBroadcastManager.sendBroadcast() 의 경우 송신자 내부 프로세스에서만 메세지를 전달한다. 해당 Broadcast message 를 앱 내부에서만 사용한다면 해당 메서드를 사용하는 것이 효율적이다. 프로세스간 통신이 불필요하며 속도 및 보안적으로도 훨씬 더 유리한 방법이다.

* 매개변수로 action이 추가된 Intent를 보내줘야함. 

```
예) intent.setAction("com.example.test");
sendBroadcast(intent);
```

소스: [https://medium.com/@eevee300/android-broadcast-receiver-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-84d3ce07db88](https://medium.com/@eevee300/android-broadcast-receiver-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-84d3ce07db88)

#### 메시지 받는 방법

onRecieveMessage(Context, Intent) 를 사용한다. 메니페스트에 등록한 경우에는 BroadCastReceiver를 상속하는 클래스를 만들고, 액티비티 컨텍스트를 통해 등록한 경우에는 액티비티 내부에서 브로드캐스트리시버의 익명 클래스를 만들면 된다.

참고로 BroadcastReceiver은 추상클래스로 그 중 추상 메소드는 onReceive() 메소드 하나이다.

<br/>

> 참조

[안드로이드 면접대비](https://velog.io/@ptm0304/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C)