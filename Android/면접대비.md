# CustomView

* 기존에 있는 View (ImageView, TextView 등) 으로 표현할 수 없는 모양의 View를 구현해야 할때 필요하다. View를 상속받는 자손 클래스를 만들어서 구현한다.
* 구현 방법
    1. API에서 제공하는 기존 View를 상속해서 해당 View를 약간 변형시킨 View
    2. 기존 API에 전혀 존재하지 않는 뷰는 최상위 클래스인 View를 상속받아 메서드를 오버라이드. 즉, onDraw(), onMeasure(), onKeyDown()과 같이 시작하는 키워드가 ‘on’인 수퍼 클래스 메서드를 오버라이드
        * onDraw():
            * 뷰를 실제로 그릴때 사용
            * Canvas 객체를 매개변수로 받음
                * Canvas 객체는 어떤 도형을 그릴지 설정
                * Paint 객체는 도형의 색, 스타일, 글꼴 등을 설정
        * protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
            * 뷰의 크기를 설정할 때 사용
    3. 여러 뷰를 합쳐서 한번에 출력하기 위한 뷰(여러 뷰가 결합된 형태가 반복되서 사용될 때)
        * ViewGroup이나 LinearLayout 같은 Layout 클래스를 상속받아 작성

<br/>

# 컴포넌트

Android 앱은 컴포넌트로 구성되어 있는데 Activity, Service, Broadcast Receiver, Content Provider 이를 4대 컴포넌트라고 부른다. 각 컴포넌트는 하나의 독립된 형태로 존재하며, 정해진 역할을 수행한다. 참고로 컴포넌트는 앱의 구성 단위로 컴포넌트를 조합하여 하나의 앱을 만드는 것을 의미한다.

<br/>

# Activity

화면에 UI를 표시하는 기본요소. 대부분의 경우 액티비티는 꽉찬 화면을 구성하지만, 예외적으로 floating windows, multi-window mode 처럼 화면의 일부를 차지하게 할수 있다.

Acitivty 의 종류 중 하나로 FragmentActivity가 있는데, 이는 nested fragment, 즉 fragment 안에 다른 fragment가 있는 경우 고려할만 하다.

AppCompatActivity는 안드로이드 하위버전의 안드로이드를 지원하기 위해 사용된다. 참고로 AppCompatActivity는 FragmentActivity를 상속한다.

<br/>

## Activity Life Cycle

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa48a7350-eb06-4f33-8ddc-96e6e8ab5286%2F_2021-03-16__11.42.38.png?table=block&id=f61a6c9c-209e-42f0-bfde-8187148ee1f9&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=850&userId=&cache=v2)

액티비티의 상태는 크게 3가지로 나눌 수 있다.

* 활성 상태(create, start, resume)
* 일시정지 (pause)
* 멈춤 (stop, destroy)

액티비티는 각각의 상태에 따른 콜백 메소드들이 존재하는데, 일반적으로 순서는

* onCreate()
    * 이 함수는 필수적으로 구현해야한다.
    * 전체 LifeCycle 동안 "한 번"만 발생한다.
    * 이 메서드에는 XML, 멤버 변수 정의, 일부 UI구성 등 설정을 한다.
    
* onStart()
    * 활성상태에 들어가면 이 함수가 호출된다. (사용자한테 보여지기 직전)
    * 호출되면 포그라운드에 보내 상호작용을 할 수 있도록 준비한다.
    * 주로 UI를 관리하는 코드를 초기화 한다. 이 메서드는 매우 빠르게 완료되고 바로 onResume을 호출한다.
    
* onResume()
    * 사용자한테 화면에 보여지고 상호작용하는 메서드이다.
    * 어떤 이벤트가 발생하여 앱에서 포커스가 떠날 때까지 이 상태에 머무른다.
    * 이 상태에서는 생명주기 구성요소가 포그라운드에서 사용자에게 보이는 동안 실행해야 하는 모든 기능을 활성화 한다. (예: 카메라 미리보기)
    * 방해가 되는 이벤트가 발생하면 일시중지 상태에 들어가고, 시스템이 onPause()를 호출한다. (예: 전화가 오거나, 사용자가 다른 화면으로 이동하거나, 기기 화면이 off될 때)
    
* onPause() 
    * 사용자가 화면을 떠날 때 시스템이 첫 번째로 이 메서드를 호출한다. (상태가 포그라운드에 있지 않게 되었다는 것을 나타냄)
    * 포그라운드에 있지 않을 때 실행할 필요가 없는 기능을 모두 정지할 수 있다. (예: 카메라 미리보기 정지)
    * 시스템 리소스, 센서 핸들(GPS), 사용자가 필요로 하지 않을 때 배터리 수명에 영향을 미칠 수 있는 모든 리소스를 해제할 수도 있다. (UI 관련 리소스와 작업을 완전히 해제하거나 조정할 때는 onPause보다 onStop을 사용하는 것이 좋다. 멀티윈도우 모드 or 화면분할 때문)
    * 이 메서드는 아주 잠깐 실행되므로 저장 작업을 하기에는 시작이 부족할 수 있다. 사용자 데이터를 저장하거나, 네트워크를 호출하거나, 데이터베이스 트랜잭션을 실행해서는 안된다. 이 메서드가 끝나기 전에 완료하지 못할 수 있다. 무거운 작업을 onStop에서 하고 데이터 저장은 viewModel, onSaveInstanceState()를 참조.
    
    > 일반적인 다이얼로그는 activity가 아니기 때문에 onPause()를 호출하지 않는다. 권한요청은 다이얼로그 처럼 보이는 ui일뿐 실제로 동작은 권한을 허용할 것인지 거절할 것인지에 대한 ui를 띄우므로 onPause()를 호출한다.
    
* onStop()
    
    * 포커스가 완전히 빠졌을 때 시스템은 이 콜백 메서드를 호출한다. (화면전체가 가려졌을 때 또는 백그라운드로 갔을 때)
    * 이 메서드에서는 앱이 사용자에게 보이지 않는 동안 앱이 필요하지 않는 리소스를 해제하거나 조정해야 한다. (예: 애니메이션 중지, 세밀한 위치 업데이트에서 대략적인 위치 업데이트로 전환할 수 있다)
    * onStop()에서 무거운 작업을 실행해야 한다고 했는데 예를들어 정보를 데이터베이스에 저장해야하는데 적절한 위치를 찾지 못했다면 이 메서드에서 저장할 수 있다. (하지만 이 함수는 항상 호출되는 것은 아니며 메모리가 부족할 경우 호출이 안될 수도 있다)
    
* onDestroy()
    * Activity가 소멸되기 전에 호출된다. 시스템은 다음 중 하나에 해당할 때 이 콜백을 호출한다.
        1. 활동이 종료되는 경우 (스택에서 날리거나 finish()를 호출)
        2. 구성 변경(예: 기기회전 또는 멀티 윈도우모드)으로 인해 시스템이 일시적으로 활동을 소멸시키는 경우
    * onStop()에서 해제하지 않은 모든 리소스를 해제해야 한다.
    * 이 메서드가 호출되는 경우 시스템이 즉시 인스턴스를 생성한 다음, 새로운 구성에서 인스턴스에 관해 onCrate()를 호출한다.  

* onRestart()
    * onStop()상태에 있던 화면이 다시 접근 했을 때 호출되는 콜백함수

<br/>

### 액티비티에서 액티비티로 이동할 때 LifeCycle 순서

1. 액티비티에서 문자가 왔을 경우(화면이 일부 가려졌을 때)

onCreate() ~ onResume() -> 문자옴 -> onPause() -> 문자사라짐 -> onResume()

2. A 액티비티에서 B 액티비티로 이동

A onCreate() ~ onResume() -> 화면이동 클릭 -> A onPuase() -> B onCreate() ~ onResume() -> A onStop() .. onDestroy() (상황에 따라)

3. 액티비티에서 백그라운드로 갔다 다시 포그라운드로 복귀 시

onCreate() ~ onReume() -> 홈버튼(백그라운드) -> onPause() -> onStop() -> 앱 복귀 -> onRestart() -> onStart() -> onResume()

<br/>

### Activity에서 configuration changes가 될 때 LifeCycle 순서

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faa3d6c43-d00b-4646-a18f-174687d86a76%2F_2021-03-18__6.05.52.png?table=block&id=750a3e7a-cf1f-483a-a45b-2a9b663c40db&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=640&userId=&cache=v2)

<br/>

주목할 점은 사용자가 홈버튼을 누르거나 다른 액티비티가 화면을 차지했을 때 onPause() -> onStop 상태가 되는데, 이때 액티비티의 상태는 메모리에 보관되게 되며, 기기의 RAM 메모리가 부족하게 되면 시스템의 판단에 따라 액티비티는 destroy 된다.

또, 안드로이드에서는 액티비티의 configuration이 바뀌면 (화면 회전이나 멀티 윈도우 모드로 전환 같은 경우) 액티비티가 완전히 소멸 (destroy) 된후 재시작하게 되는데, 이때 액티비티의 상태를 보존하기 위해 사용되는게 onSaveInstanceState, onRestroeInstanceState, onCreate(Bundle) 이다.

<br/>

# Fragment

프래그먼트는 액티비티의 부분을 동적으로 동작시키기 위해 생긴 개념이다. 쉽게 비유를 들어 설명하자면, 앱하나를 서랍이라고 하고 액티비티를 서랍의 한칸이라고 하면, 프래그먼트는 서랍안의 부분부분을 나눠서 정리하는 정리함의 한 칸이라고 생각하면 된다.

프래그먼트를 사용하는 대표적인 예로 탭레이아웃이 있는데, 탭을 눌러서 다른화면으로 전환하는 앱의 경우이다. 이때 한 액티비티안에서 탭을 눌렀을 때 보여지는 프래그먼트만 바꾸게 되는데, 프래그먼트는 액티비티와 달리 스택에 쌓이지 않기 때문에 백버튼을 누른다고 해서 이전 프래그먼트로 돌아가지 않는다. 만약 어떤 이유로 프래그먼트를 스택에 넣고 싶다면 개발자가 직접 backStack에 추가해주는 방법도 있다.

<br/>

## Fragment 생명주기

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F954e40e8-e5a9-468f-ae02-1c2445380f09%2F_2021-03-16__3.22.27.png?table=block&id=48dee9e4-2401-47b1-b333-48802997ad3a&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=680&userId=&cache=v2)

* onAttach(Activity)   
    * 액티비티에서 프래그먼트가 호출될 때 최초 한번 호출되는 함수
* onCreate(Bundle)   
    * 프래그먼트가 생성될 떄 호출되는 함수   
* onCreateView(LayoutInflater, ViewGroup, Bundle)
    * 프래그먼트의 뷰를 생성하는 함수   
* onActivityCreated(Bundle)
    * 액티비티에서 onCreate()가 호출 된 프래그먼트에서 호출되는 함수 
* onStart()   
    * 프래그먼트가 사용자한테 보여지기 직전 호출되는 함수 
* onResume()
    * 프래그먼트가 사용자와 상호작용할 수 있는 상태  
* onPasue()   
    * 화면이 일부 가려졌을 때 호출
* onStop()  
    * 프래그먼트가 화면에 사라졌을 때 호출  
* onDestroyView() 
    * 프래그먼트의 View가 사라질때 호출되는 함수 
* onDestroy()
    * 프래그먼트가 제거될 때 호출되는 함수
* onDetach()  
    * 프래그먼트가 액티비티와 연결이 종료될 때 호출되는 함수

액티비티와 생명주기가 거의 비슷한데, onAttach, onCreateView, onDestroyView, onDetach라는 콜백이 추가된다. onCreateView에서 프래그먼트에 맞는 UI Layout을 리턴한다.

<br/>

## Fragment Manager

* 프래그먼트를 추가, 삭제 또는 교체하고 백스택에 추가하는 등의 작업을 실행하는 클래스
* 프래그먼트의 변경사항 집합을 트랜잭션이라고 한다.

## Fragment Transaction

* 각 트랜잭션은 수행하고자 하는 변경사항의 집합이다. 변성사항을 설정하려면 add(), remove(), replace()와 같은 메서드를 사용해야 한다.

<br/>

# Activity와 Fragment의 차이점

1. 액티비티는 독립적으로 활용할 수 있다.
2. 프래그먼트는 액티비티에 종속되어 있다.
3. 액티비티는 전체화면을 차지하지만 프래그먼트는 전체 화면이 아니여도 되며 디자인에 많은 유연성을 가지고 있다.
4. 액티비티는 자동적으로 백스택에 넣어지고 프래그먼트는 트랜잭션을 통해서 요청해야 한다.

<br/>

# BroadcastReceiver

안드로이드의 컴포넌트 중 하나로 원하는 메시지를 보내거나 받을 수 있는 컴포넌트이다. 예를 들면, 충전기를 꼽았다던지, SMS문자메시지, 전화가 온다거나 하는 일에 대한 메세지를 받을 수 있다. sendBroadCast() 라는 메소드를 통해 메세지를 보내면 리시버에서 메세지를 받을 수 있다.

BroadCastReceiver를 등록하는 방법은 크게 두가지가 있다. 첫번째로 정적으로 등록하는 방법인데, AndroidManifest 파일에 리시버라는 태그를 이용해서 추가하는 방법이다. 이 방법을 사용하면 앱이 실행중이지 않을때도 메세지를 받을 수 있다.

두번째 방법으로 동적 등록은 액티비티의 Context를 통해 등록한다. Context의 registerReceiver() 메소드를 통해 등록할 수 있는데, 이렇게 등록하게 되면 액티비티가 destroy되기 전까지만 메세지를 받을 수 있다. unRegisterReceiver()를 통해 리시버가 더 이상 필요하지 않을때 해제시킬 수 있다.

#### 메시지를 보내는 방법

sendOrderBroadcast() 는 한번에 한 수신자에게만 메세지를 전달한다. BroadcastReceiver를 따라 전파됨에 따라 다음 수신자에게 계속 메세지를 전달할수도, 또는 차단할수도 있다.
sendBroadcast()는 모든 수신자에게 메세지를 전파한다.
LocalBroadcastManager.sendBroadcast() 의 경우 송신자 내부 프로세스에서만 메세지를 전달한다. 해당 Broadcast message 를 앱 내부에서만 사용한다면 해당 메서드를 사용하는 것이 효율적이다. 프로세스간 통신이 불필요하며 속도 및 보안적으로도 훨씬 더 유리한 방법이다.

* 매개변수로 action이 추가된 Intent를 보내줘야함. 

```
예) intent.setAction("com.example.test");
sendBroadcast(intent);
```

소스: [https://medium.com/@eevee300/android-broadcast-receiver-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-84d3ce07db88](https://medium.com/@eevee300/android-broadcast-receiver-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-84d3ce07db88)

#### 메시지 받는 방법

onRecieveMessage(Context, Intent) 를 사용한다. 메니페스트에 등록한 경우에는 BroadCastReceiver를 상속하는 클래스를 만들고, 액티비티 컨텍스트를 통해 등록한 경우에는 액티비티 내부에서 브로드캐스트리시버의 익명 클래스를 만들면 된다.

참고로 BroadcastReceiver은 추상클래스로 그 중 추상 메소드는 onReceive() 메소드 하나이다.

<br/>

# Content Provider

앱간의 데이터 교환을 위해 다른 앱에게 데이터를 제공하고 데이터를 가져올 수 있게 하는 컴포넌트이다. 즉, 앱 간의 데이터 공유를 목적으로 사용되는 컴포넌트이다. 실제로 앱의 데이터베이스는 해당 앱만 접근 가능하기 때문에 다른 앱의 데이터를 가져오기 위해서는 ContentProvider를 사용해야 한다.

추가: CalenderProvider ContactsProvider

<br/>

# Service

백그라운드에서 오래 실행되는 작업을 할때 사용되는 구성요소이다. 다른 애플리케이션 구성요소가 서비스를 실행할 수 있고, 서비스는 다른 애플리케이션으로 전환되더라도 계속 실행된다.

서비스는 포그라운드, 백그라운드, 바인드 서비스가 있다.

* 포그라운드 서비스는 사용자에게 보이는 서비스를 제공하고 알림을 표시해야 한다. 음악 플레이어 앱을 사용해 노래를 트는 경우를 생각하면 된다.
* 백그라운드 서비스는 사용자에게 보이지 않는 작업을 수행한다. 예를 들어 앱이 저장소를 압축하는데 서비스를 사용하였다면, 이는 대개 백그라운드 서비스이다.
* 바인드 서비스는 다른 앱 구성요소가 bindService() 메소드를 호출하여 구성요소가 서비스에 바인딩되는 경우이다. 바인딩된 서비스는 해당 구성요소와 서로 상호작용할 수 있고, 하나의 서비스가 여러개의 구성요소와 바인딩되는 경우도 가능하다. 이때 모든 바인딩된 구성요소에서 바인딩이 해제되면 서비스는 소멸한다.

<br/>

## 서비스와 쓰레드

서비스는 쓰레드가 아니라 단순히 백그라운드에서 실행 될수 있는 구성요소이고 기본적으로 메인쓰레드에서 실행된다. 만약 서비스가 집약적이거나 메인쓰레드와 별도로 작업을 수행해야 한다면, 서비스 안에서 새로운 쓰레드를 만들어서 작업해야 한다.

<br/>

## 안드로이드 8 이후의 서비스와 브로드캐스트 리시버

안드로이드 8 이후 사용자와의 상호작용과 별개로 백그라운드에서 수행되는 메니페스트로 등록된 브로드캐스트리시버와 서비스에 대한 제한이 강화 되었다.

브로드캐스트 리시버의 경우 예전에는 시스템으로 부터 충전기가 연결되었다던지 하는 메세지를 받게 되면 저장소 정리를 한다던지 하는 식으로 많이 이용됬었는데, 이런 식으로 백그라운드에 등록되는 앱이 많아지게 되면 시스템에 과부하가 걸릴 수 있어서, 안드로이드 8 이후로 암시적 브로드캐스트에 대한 리시버의 등록을 제한시켰다. 암시적 브로드캐스트란 특정 앱을 대상으로 하지 않는 브로드캐스트이다.

백그라운드 서비스는 우선순위가 높은 메세지만 받을수 있게 되며, sms/mms와 같은 메세지는 받을 수 있다. 또한, 알림에서 PendingIntent를 수행하는 일 또한 가능하다.

구글에서는 이러한 제한 사항으로 못하게 된 작업들을 JobScheduler(WorkManager)를 통해 수행하길 권장한다.

<br/>

# Intent

인텐트는 컴포넌트를 실행하기 위해 시스템에 넘기는 정보로, 해당 객체를 통해 컴포넌트 간에 데이터를 전달할 수도 있다.

## Intent Types

### Explicit Intent(명시적 인텐트)

명시적 인텐트는 인텐트에 클래스 객체나 컴포넌트 이름을 지정하여 호출할 대상을 확실히 알 수 있는 경우에 사용한다(주로 애플리케이션 내부에서 사용)

<br/>

### Implicit Intent(암시적 인텐트)

인텐트의 액션과 데이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용합니다. 즉 설치된 애플리케이션에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F716ac673-b17b-4526-a4b4-970e0bf99c57%2F_2021-03-18__5.38.00.png?table=block&id=9d3e1762-c15c-4a43-ae90-8a589f544585&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=1750&userId=&cache=v2)

<br/>

## Intent Filter

암시적 인텐트를 통해 사용자로 하여금 어느 앱을 선택할지 선택하도록 할 때 IntentFilter가 필요하다.

<br/>

## PendinIntent

펜딩 인텐트는 이름에서 볼수 있듯이 보류된 인텐트로, 당장 해당 작업을 다른 컴포넌트에 요청하는게 아닌 특정시점에 자신이 아닌 컴포넌트가 다른 컴포넌트에게 펜딩 인텐트를 사용하여 작업을 요청한다는 특징이 있다.

대표적으로, 사용자가 Notification을 클릭했을 때 특정한 작업을 수행시키거나, 위젯을 통해 앱을 실행시키거나, 미래의 특정 시점에 실행되는 인텐트를 선언하는 경우에 펜딩 인텐트를 사용한다.

펜딩인텐트의 인스턴스를 생성하는 방법은 크게 네가지가 있다.

* getActivity(Context, int, Intent, int): 매개변수에 포함된 Intent를 통해 한가지 액티비티를 실행시킬때 사용
* getActivities(Context, int, Intent[], int): 매개변수에 포함된 Intent배열을 통해 여러개의 액티비티를 실행시킬때 사용. 이때 Context.* * startActivities와 똑같이 작동한다. startActivities는 거의 사용되지 않지만 액티비티들을 백스택에 넣고 싶을때 사용되기 때문에 실행된 액티비티에서 백버튼을 눌렀을때 다른 액티비티로 이동하고 싶다면 사용한다.
* getBroadcast(Context, int, Intent, int): context.sendBroadCast(intent)를 하고 싶을때 사용
* getService(Context, int, Intent, int): Intent를 통해 context.startService(intent)를 하고 싶을때 사용

<br/>

# ANR(Application Not Responding)

Android 앱의 UI 스레드가 너무 오랫동안 차단되면 'ANR(애플리케이션 응답없음)' 오류가 나타나게 된다. 앱이 포그라운드에 있으면 아래와 같이 시스템에서 사용자에게 다이얼로그를 표시한다.

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F00b81c48-06ba-4f7c-a3e5-66ca476a48ac%2F_2021-03-16__5.04.14.png?table=block&id=c2a6271d-c3bc-4b65-a9cb-9f1dda80a76a&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=550&userId=&cache=v2)

안드로이드 프레임워크에서 ANR 관련된 내용은 com.android.server.am.ActivityManagerService에서 확인 할 수 있다(ActivityManagerService는 system_server 프로세스에서 실행된다).

<br/>

## ANR이 발생하는 경우

* 화면 터치와 키 입력에서 ANR

메인 스레드를 어디선가 이미 점유하고 있다면 키 이벤트를 전달하지 못하는데, 이벤트를 전달할 수 없는 시간이 타임아웃을 넘는다면 이때 ANR이 발생한다. **키 이벤트인 볼륨, 메뉴, 백 키의 경우는 눌리고서 5초 이상 지연 시 바로 ANR을 발생** 시킨다. 참고로 홈 키와 전원 키는 앱과 별개로 동작하고 ANR 발생과는 무관하다.

터치 이벤트는 경우가 다르다. 터치 이벤트도 메인 스레드가 사용 중이라면 대기하는 것은 동일하지만 타임아웃 된다고 해서 바로 ANR이 발생하지 않는다. 그 다음으로 이어서 터치 이벤트가 왔을 때는 **두 번째 터치 이벤트가 전달되지 않는 시간이 타임아되면 ANR이 발생** 한다. 예를 들어, 어디선가 메인 스레드를 블로킹하고 있는데 이때 첫 번째 터치 이벤트만으로는 ANR이 발생하지 않는다. 두 번째 터치 이벤트가 있고서 5초가 지나면 그때서야 ANR이 발생한다.

* Message 처리 각각이 5초 이내라도 총합 처리 시간 영향

가끔 혼동하는 경우가 있는데 특정 Message 처리가 5초가 넘더라도 그 사이에 터치가 없을 때는 문제가 발생하지 않는다. 예를들어, for문을 0부터 4까지 돌리는데 2초씩 메인 스레드를 블로킹하고 있다고 가정하자. 5개의 Message를 처리하는 시간은 총 10초다. 가만히 두면 문제가 없다. 하지만 Message를 처리하는 중에 화면을 두 번 이상 터치하면 ANR이 발생한다. (앞에 쌓여있는 Message를 먼저 처리하느라 터치 이벤트에 대한 처리가 지연되는 것)

* 서비스나 브로드캐스트 리시버에서도 5초 이내로 Message 처리 필요

예를 들어 50초 동안 BroadcastReceiver의 onReceive()가 실행되고 있을 때 액티비티 화면을 터치하면 역시 ANR 발생 가능성이 높다. 브로드캐스트 리시버나 서비스도 액티비티가 떠있는 상태를 고려해서, 타임아웃을 5초라고 생각하는 편이 낫다. 결론적으로 브로드캐스트 리시버의 경우에 오래 걸리는 작업이 있다면 서비스로 넘겨서 실행해야 하고, 서비스에서는 다시 백그라운드 스레드를 이용해야 한다.

<br/>

# MainThread + Handler

애플리케이션은 성능을 위해 멀티 스레드를 많이 활용하지만, UI를 업데이트하는 데는 단일 스레드 모델이 적용된다. 멀티 스레드로 UI를 업데이트하면 동일한 UI 자원을 사용할 때 교착 상태(deadlock), 경쟁 상태(race condition) 등 여러 문제가 발생할 수 있다. 따라서 UI 업데이트를 메인 스레드에서만 허용한다.

앱 프로세스가 시작되면서 메인 스레드가 생성된다. 컴포넌트의 생명주기 메서드와 그 안의 메서드 호출은 기본적으로 메인 스레드에서 실행된다. 메인 스레드는 UI를 변경할 수 있는 유일한 스레드이기 때문에 메인 스레드를 UI 스레드로 부르기도 한다. 서비스, 브로드캐스트 리시버, Application은 사용자 인터페이스가 아니기 때문에, UI 스레드에서 실행된다고 하면 개념을 혼동하기 쉽다. UI를 변경하는 유일한 수단이라는 의미를 강조하기 위해서 UI 스레드를 쓴다고 이해하면 편할 것 같다.

<br/>

## [안드로이드 애플리케이션에서 메인 스레드](https://medium.com/write-android/%EB%A9%94%EC%9D%B8-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-handler-part-1-handler%EC%99%80-looper-%EA%B7%B8%EB%A6%AC%EA%B3%A0-messagequeue%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-f0bee443d71e)

안드로이드 프레임워크 내부 클래스인 android.app.ActivityThread가 애플리케이션의 메인 클래스이고, ActivityThread의 main() 메서드가 애플리케이션의 시작 지점이자 메인 스레드가 되는 곳이다. ActivityThread는 어떤 것도 상속하지 않은 클래스다. 액티비티만 관련되어 있는 것도 아니고 모든 컴포넌트들이 다 관련되어 있다. AppCompatActivity → FragmentActivity → ComponentActivity → androidx.core.app.ComponentActivity → Activity → ActivityThread 로 들어가면 볼 수 있다.

``` java
ActivityThread.java

public static void main(String[] args) {
    /* ..*/
    Looper.prepareMainLooper();  // 1번
		/* .. */
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
  
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
		/* .. */   
		Looper.loop(); // 2번

    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

1번 -> 메인 Looper를 준비한다.

2번 -> UI Message를 처리한다. Looper.loop() 메서드에서 무한 반복문이 있기 때문에 main 메서드는 프로세스가 종료될 때까지 끝나지 않는다.

<br/>

## Looper 클래스

![](https://media.vlpt.us/images/changhee09/post/c4263cec-cdbd-495b-95e9-69f5fd25df70/image.png)

Looper는 이름에서도 알 수 있듯이 하나의 반복 작업을 맡고 있는 역할로 이해할 수 있다. 실제로 프로세스가 종료될 때까지, 무한 반복문을 통해 반복 작업을 수행하게 된다. 여기서 Looper가 맡은 반복작업은 구체적으로 MessageQueue에 있는 message, runnable을 계속해서 하나씩 꺼내주는 작업이 되겠다.

<br/>

* 스레드별로 Looper 생성

Looper는 TLS(thread local storage)에 저장되고 꺼내어진다. ThreadLocal<Looper>에 set() 메서드로 새로운 Looper를 추가하고, get() 메서드로 Looper를 가져올 때 스레드별로 다른 Looper가 반환된다. 그리고 Looper.prepare()에서 **스레드별로 Looper를 생성** 한다. 특히 메인 스레드의 메인 Looper는 ActivityThread의 main() 메서드에서 Looper.prepareMainLooper()를 호출하여 생성한다. Looper.getMainLooper()를 사용하면 어디서든 메인 Looper를 가져올 수 있다.

* Looper별로 MessageQueue를 가짐

**Looper는 각각의 MessageQueue를 가진다.** 특히 메인 스레드에서는 이 MessageQueue를 통해서 UI 작업에서 경쟁 상태를 해결한다.

<br/>

## Message와 MessageQueue

Message란 실제 수행해야할 작업에 대한 명세가 들어있는 자료구조이며, MessageQueue는 Message를 담는 자료구조이다. 이를 Looper와 관련지어 본다면, MessageQueue는 Looper의 반복 대상이며, Message는 Looper의 실질적인 반복의 결과물로 이해할 수 있다. Message를 생성할 때는 사용한 message 객체를 다시 초기화하여 재사용하는 방식인 오브젝트 풀 방식을 사용한다.

<br/>

## Handler 클래스

### Handler 역할 두가지

Handler가 가진 역할을 크게 아래 두가지로 요약할 수 있다.

* Message를 MessageQueue에 보내는 역할
* MessageQueue에서 꺼낸 Message를 처리하는 역할(MessageQueue에서 Message를 꺼내는 역할은 Looper의 역할)

``` java
Handler()
Handler(Handler.Callback callback)
Handler(Looper looper)
Handler(Looper looper, Handler.Callback callback)
```

Handler가 작업을 처리하기 이전에, Handler는 (MessageQueue에서 Message를 꺼내줄) Looper와 연결되어 있어야 한다. 따라서 Handler의 생성 또한 Looper와 연결지어 이해해야한다. Looper를 생성하는 방법은 위와 같이 총 4가지가 있는데, 첫 번째와 두 번째 생성자를 통해 생성하는 방법은 deprecated 됐다. 암시적으로 Looper를 선택했을 때, 아래와 같은 문제가 발생할 수 있기 때문이다.

* Handler가 새 작업을 기대하지 않고 종료하는 경우의 작업이 자동으로 손실되는 bugs
* Looper가 활성화되지 않은 스레드에서 Handler가 생성되는 경우의 crashes
* Handler가 연결된 스레드가 개발자가 예상한 것과 다를 때의 경쟁 상태(Race conditions)

<br/>

### Handler 동작

위에서 언급했듯이 Handler는 Message를 MessageQueue에 보내는 것과 Message를 처리하는 기능을 함께 제공한다. Message Queue에 Message를 보낼 때, **Message의 형태** 와 **Message의 처리 시점** 에 따라 다양한 메서드를 사용한다.

#### Message의 형태

* send로 시작하는 메서드는 Message를 보낸다.
* post로 시작하는 메서드는 Runnable 형태의 Message를 다룬다.

#### Message의 처리 시점에 따른 함수

* ~Delayed()
* ~AtTime()
* ~AtFrontOfQueue()

<br/>

### Handler 용도

Handler는 일반적으로 UI 갱신을 위해 사용된다.

* 백그라운드 스레드에서 UI 업데이트: 백그라운드 스레드에서 네트워크나 DB 작업 등을 하는 도중에 UI를 업데이트 한다. AsyncTask에서도 내부적으로 Handler를 이용해서 onPostExecute() 메서드를 실행해서 UI를 업데이트한다.

* 메인 스레드에서 다음 작업 예약: UI 작업 중에 다음 UI 갱신 작업을 MessageQueue에 넣어 예약한다. 작업 예약이 필요한 경우가 있는데, 예를 들어 onCreate() 메서드에서(소프트 키보드를 띄우는 것이나, ListView의 setSelection()) 작업을 할 경우 잘 동작하지 않는다. 이때 Handler에 Message를 보내면 현재 작업이 끝난 이후의 다음 타이밍에 Message를 처리한다.

<br/>

### Handler의 타이밍 이슈

원하는 동작 시점과 실제 동작 시점에서 차이가 생기는데, 이런 타이밍 이슈는 메인 스레드와 Handler를 이해하고 나면 해결할 수 있다. Activity의 onCreate() 메서드에서 Handler의 post() 메서드를 실행하면 어느 시점에 실행될까? 실제 post() 메서드에 전달되는 Runnable이 실행되는 시점은 언제일까? 메인 스레드에서는 한 번에 하나의 작업밖에 못하고, 여러 작업이 서로 엉키지 않기 위해서 메인 Looper의 MessageQueue에서 Message를 하나씩 꺼내서 처리한다는 것을 염두에 두자. 

MessageQueue에서 Message를 하나 꺼내오면 onCreate() ~ onResume()까지 쭉 실행이 된다. 그럼 답은 나왔다. **onCreate()에서 Handler의 post()에 전달한 Runnable은 onResume() 이후에 실행**된다.

<br/>

### 지연 Message는 처리 시점을 보장할 수 없다.

Handler에서 전달된 지연 Message는 지연 시간을 정확하게 보장하지 않는다. MessageQueue에서 먼저 꺼낸 Message 처리가 오래 걸린다면 실행은 당연히 늦어진다.

예를들어 0.2초 후에 로그를 남기는 Handler가 있고 0.5초를 멈추는 Handler가 있다고 가정하면 로그를 남기는 Handler는 0.2초 후가 아닌 0.5초가 지난 후에 로그를 남긴다.

<br/>

# Dialog and Toast, SnackBar

## [Dialog](https://developer.android.com/guide/topics/ui/dialogs)

다이얼로그는 사용자에게 추가 정보를 입력 또는 결정을 내릴 때 표시하는 작은 화면을 뜻한다.

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F427b9cd3-9988-4bb1-8278-7b393c7153b4%2F_2021-03-17__2.02.18.png?table=block&id=b792ac73-5e17-4062-a015-4b00a1d7f457&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=920&userId=&cache=v2)

<br/>

## [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts)

토스트 메세지는 작은 팝업으로 메세지에 필요한 공간만 차지하고 진행 중인 작업을 그대로 표시되고 사용자와 상호작용도 유지된다. 토스트 메세지는 시간이 초과하면 자동으로 사라진다.

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2e0c10f2-f45b-4988-b6a9-90b5e5d12a2e%2F_2021-03-17__2.04.16.png?table=block&id=028c04f9-73b5-4e4d-8706-79793ce3f3c9&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=590&userId=&cache=v2)

<br/>

## [SnackBar](https://developer.android.com/training/snackbar/action)

SnackBar는 토스트와 비슷하지만 사용자가 메시지에 응답할 수 있다.

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5f118d85-3dcc-47cc-af68-ab304c452665%2F_2021-03-17__2.06.11.png?table=block&id=ec3c3825-9b19-41a6-8d54-acc29dfc7a85&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=830&userId=&cache=v2)

<br/>

# Annotation

특정 클래스, 변수, 메소드 등에 붙이는 코드로 해당 타겟의 기능을 좀 더 명확하게 해주는 역할을 수행한다.

* [Kotlin Annotation](https://codechacha.com/ko/kotlin-annotations/)
* [Android Annotation](https://velog.io/@changhee09/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EC%82%AC%EC%9A%A9)
* [Android와 Annotation](https://tosslab.github.io/android/2015/03/01/02.android-%EC%99%80-annotation.html)

<br/>

# Context

## [Context](https://arabiannight.tistory.com/284)

Context가 없으면 액티비티를 시작할 수도, 브로드캐스트를 발생시킬 수도, 서비스를 시작할 수도 없다. 리소스에 접근할 때도 Context를 통해서만 가능하다. Context는 여러 컴포넌트의 상위 클래스이기 때문이다.
즉, 안드로이드 시스템이 어플리케이션이나 컴포넌트 등을 관리하기 위해 만든 것이다.

Context는 추상 클래스인데 메서드 구현이 거의 없고 상수 정의와 추상 메서드로 이루어진다. Context를 직접 상속한 것은 ContextWrapper이고 ContextWrapper를 상속한 것은 Activity, Service, Application이다(BroadCastReceiver와 ContentProvider는 Context를 상속한 것이 아니다).

<br/>

## ContextWrapper 클래스

ContextWrapper 클래스는 Context를 래핑한 ContextWrapper(Context base) 생성자를 갖고 있다.

``` java
public ContextWrapper(Context base) { // 1
    mBase = base;
}

protected void attachBaseContext(Context base) { // 2
    if (mBase != null) {
        throw new IllegalStateException("Base context already set");
    }
    mBase = base;
}

public Context getBaseContext() {
    return mBase;
}

@Override
public Context getApplicationContext() {
    return mBase.getApplicationContext();
}

@Override
public void startActivity(Intent intent) {
    mBase.startActivity(intent);
}

@Override
public void sendBroadcast(Intent intent) {
    mBase.sendBroadcast(intent);
}

@Override
public Resources getResources() {
    return mBase.getResources();
}
```

1, 2 에서 base 파라미터에 전달되는 것은 Context의 여러 메서드를 직접 구현한 ContextImpl 인스턴스이다. ContextWrapper의 여러 메서드는 base의 메서드를 그대로 다시 호출한다. Activity, Service, Application은 1의 생성자를 사용하지 않고, 실제로는 2의 attachBaseContext() 메서드를 사용한다. Activity, Service, Application 모두 내부적으로 ActivityThread에서 컴포넌트가 시작된다. 이때 각 컴포넌트의 attach() 메서드를 실행하고 attach() 메서드에서 또다시 attachBaseContext() 메서드를 호출한다.

ContextWrapper에 getBaseContext()와 getApplicationContext() 라는 2개의 메서드가 별도인 것을 보면 싱글톤이 아닌 것을 알 수 있다. Activity, Service, Application 컴포넌트는 각각 생성한 ContextImpl을 하나씩 래핑하고 있고 getBaseContext()는 각각 ContextImpl 인스턴스를 리턴한다. getApplicationContext()는 Application 인스턴스를 리턴하는 것으로 Application은 앱에서 1개밖에 없고 어디서나 동일한 인스턴스를 반환한다.

<br/>

## ContextImpl의 메서드

* 앱 패키지 정보를 제공하거나 내/외부 파일, SharedPreferences, 데이터베이스 등을 사용하기 위한 헬퍼 메서드
* Activity, BroadcastReceiver, Service와 같은 컴포넌트를 시작하는 메서드와 퍼미션 체크 메서드
* ActivityManagerService를 포함한 시스템 서비스에 접근하기 위해서 사용되는 getSystemService() 메서드

<br/>

## Context와 하위 클래스

![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d5abf95-991d-442f-b2db-e89a030c7e5f%2Fd0fc31d12b93ba6fdbbdd63788a5fd6a.jpeg?table=block&id=61f80d01-7827-4d05-93bb-7a310623b1ad&spaceId=0c96ee45-bef3-4eab-82c9-67441a64de3e&width=1070&userId=&cache=v2)

Activity, Service, Application을 보면 ContextImpl을 직접 상속하지 않고, ContextImpl의 메서드를 호출하는 형태라는 것을 알 수 있다. 이렇게 하면 ContextImpl의 변수가 노출 되지 않고, ContextWrapper에서는 ContextImpl의 공개 메서드만 호출하게 된다. 또한 각 컴포넌트별로 사용하는 기능을 제어하기도 단순해 진다.

<br/>

## 사용 가능한 Context

Activity로 예를 들어보면 Context 인스턴스는 3개가 있다.

* Activity 인스턴스 자신(this)
* getBaseContext()를 통해 가져오는 ContextImpl 인스턴스
* getApplicationContext()를 통해 가져오는 Application 인스턴스 : Activity의 getApplication() 메서드로 가져오는 인스터스와 같다.

위 3개의 인스턴스가 다르기 떄문에 캐스팅을 함부로 하면 안된다. 이를테면 getBaseContext()로 가져오는 것을 Activity로 캐스팅하면 ClassCastException이 발생한다. View의 클래스를 보면 생성자에 Context가 들어가는데 이 Context가 어디서 온 것인지 확인해 볼 수 있다.

``` kotlin
val context1 = (view.context == this) // 1
val context2 = (view.context == baseContext) // 2
val context3 = (view.context == applicationContext) // 3
val context4 = (view.context == application) // 4

println(context1)
println(context2)
println(context3)
println(context4)

>> true
>> false
>> false
>> false
```

1에서만 true가 나오는 것을 볼 수 있다. View 클래스는 생성자에 Context가 전달되어야 하는데 Activity에 쓸 수 있는 3가지 Context 모두 다 전달 가능하다. 그러나 View와 연관이 깊은 것은 Activity이므로 Activity가 전달된 것을 이해할 수 있을 것이다.

<br/>

## 요약

리눅스 환경에서 어플리케이션을 프로세스 단위로 관리한다. Context는 프로세스 내에서 컴포넌트를 관리를 해야하고 이를 관리하기 위해 만든 추상클래스이다. 즉, 리눅스에서 프로세스를 ID를 붙여 관리하듯 안드로이드 시스템은 어플리케이션 또는 컴포넌트 등을 Context로 관리한다.

<br/>

# [LayoutInflater](https://medium.com/vingle-tech-blog/android-layoutinflater-b6e44c265408)

LayoutInfalter는 **XML에 미리 정의해둔 툴을 실제 메모리에 올려주는 역할** 을 한다. Infalter 단어의 뜻이 부불리다라는 의미로써 LayoutInfalter라는 단어에서도 유추가 가능하다. 즉, LayoutInflater는 **XML에 정의된 Resource를 View 객체로 반환** 해주는 역할을 한다. 우리가 매번 사용하는 onCreate() 메서드에 있는 setContentView(R.layout.activity_main) 또한 Inlfater 역할을 한다(이 함수 내부에서 LayoutInflater가 실행되어 view들을 객체화한다).

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmtLIe%2FbtqytUl5eEW%2Fkkss38KNJzjgQJL5kVxf6K%2Fimg.jpg)

**참고**
* [LayoutInflater](https://www.crocus.co.kr/1584)

<br/>