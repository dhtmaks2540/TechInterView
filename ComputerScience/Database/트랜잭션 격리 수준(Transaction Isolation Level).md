# 트랜잭션 격리 수준(Transaction Isolation Level)

## 트랜잭션 고립화 수준

**트랜잭션 고립화 수준(Transaction Isolation Level)은 트랜잭션의 독립성, 고립성을 유지하기 위해 데이터에 대한 접근을 허용하는 수준** 을 말한다. 로킹(Locking) 기술을 기반으로 고립화 수준을 조정하며 총 4개의 레벨로 구성되어 있다.

고립화 수준에 따라 발생할 수 있는 문제점들이 있는데, 수준이 높아질수록 문제점이 줄어드는 형태이다. 다음과 같은 문제점들이 발생할 수 있다.

1. 부정 판독(Dirty Read)

부정 판독은 **다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것** 을 말한다. 트랜잭션 T1이 특정 데이터를 갱신한 후 T2가 해당 데이터를 읽은 다음 T1이 Rollback 되면 T2는 존재하지 않은 값을 가리키게 되는 비일관된 상태에 놓이게 된다.

2. 비반복 판독(Non-repeatable Read)

비반복 판독은 **한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 갱신하거나 삭제함으로써 읽은 값이 서로 다르게 되는 현상** 이다.

3. 팬텀 판독(Phantom Read)

팬텀 판독은 **한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 추가함으로써 첫 번째 쿼리에서 없던 유령(Phantor) 레코드가 두 번째 쿼리에서 나타나는 현상** 이다.

<br/>

## 고립화 수준(Isolation Level)의 유형

1. Read uncommitted (Level 0)

**트랜잭션에서 아직 commit 되지 않고 처리 중인 데이터를 다른 트랜잭션이 읽을 수 있다.** 부정 판독, 비반복 판독, 팬텀 판독 모두 발생하는 레벨이다. SELECT문을 수행하는 경우 해당 데이터는 Shared Lock이 걸리지 않는 레벨이다.

<br/>

2. Read committed (Level 1)

**트랜잭션이 commit 된 데이터만 다른 트랜잭션이 읽을 수 있다.** 따라서 부정 판독(Dirty Read)를 방지해준다. 대부분의 DBMS에서 기본으로 채택하는 레벨이다.

<br/>

3. Repeatable Read (Level 2)

**선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제가 불가능하다.** 같은 레코드의 반본적인 판독은 동일한 값으로 반환된다. 따라서 비반복 판독(Non-repeatable Read)을 방지해준다.

<br/>

4. Serializable (Level 3)

**선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제/삽입이 불가능하다.** 따라서 새로운 레코드가 도중에 나타나지 않으므로 팬텀 판독(Phantom Read)을 방지해준다. 완벽한 정합성을 보장하는 레벨이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQ6gLP%2FbtrbVrGMjsR%2FL2l14pKah6d6rag45TmEh0%2Fimg.png)

<br/>

## 선택 시 고려사항
* Isolation Level에 대한 조정은 동시성과 데이터 무결성에 연관되어 있다.
* 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.
* 레벨을 높게 조정할 수록 발생하는 비용이 증가한다.

<br/>

# 트랜잭션 회복 기법

트랜잭션에서의 회복(recovery)은 **트랜잭션이 실행되는 동안 발생한 오류로부터 가장 가까운 정상 상태로 복귀하는 것** 이다. 주요 회복 기법으로 로그 기반, 검사점 기반, 그림자 페이지 사용 등이 있다.

* Undo : 트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소하여 복구 수행
* Redo : 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구 수행

<br/>

## 로그 기반 회복

로그 기반 회복은 지연 갱신 회복과 즉시 갱신 회복으로 나뉜다.

**지연 갱신 회복** 은 트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고 데이터베이스에는 커밋이 발생할 때까지 저장을 지연하는 방식이다. 따라서 중간에 장애가 발생하더라도 데이터베이스에 아직 기록되지 않았기 때문에 Undo 과정이 필요 없다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH2KF1%2FbtrbZMJMaqP%2Fjd940SfjNI4z4BvTauFNMK%2Fimg.png)

**즉시 갱신 회복** 은 트랜잭션 수행 도중에 발생한 변경 내용을 로그 파일에 저장하고, 모든 변경 내용을 즉시 데이터베이스에 반영하는 방식이다. 트랜잭션 완료 이전에 수행된 갱신은 미완료 갱신이라고 하며, 회복하는 경우 Undo와 Redo를 모두 수행해야 한다.

<br/>

## 검사점 기반 회복

**검사점 기반 회복** 은 체크포인트(Checkpoint) 회복이라고도 하며, 장애가 발생한 경우 이전에 처리된 트랜잭션은 제외하고 검사점 이후에 처리된 트랜잭션에 대해서만 회복 작업을 진행하는 방식이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcKLuIR%2FbtrbXihSJAj%2FvtLcPOF45EWMlW8sP4tK01%2Fimg.png)

위의 예시에서는 장애 이전의 가장 최근 검사점인 CheckPoint 2 이전의 트랜잭션 T1, T2, T3은 회복 작업에서 제외된다. 검사점 이후, 장애 발생 이전에 commiit이 완료된 트랜잭션(T4, T5)은 Undo, 장애 발생 시점까지 commit 되지 못한 트랜잭션은(T6)은 Redo를 수행한다.

<br/>

## 그림자 페이징 회복

그림자 페이징 회복은 현재 테이블은 주기억장치, 그림자 페이지 테이블은 디스크에 저장하여 트랜잭션이 성공적으로 수행되는 경우 그림자 페이지 테이블을 삭제하고, 실패할 경우 그림자 페이지 테이블을 통해서 복구하는 방식이다. 트랜잭션이 시작될 때 현재 테이블과 동일한 그림자 테이블을 생성한다.

<br/>

**참조**
* [원본링크](https://gyoogle.dev/blog/computer-science/data-base/Transaction%20Isolation%20Level.html)
* [원본링크2](https://rebro.kr/165?category=484170)