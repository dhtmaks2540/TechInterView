# 패리티 비트 & 해밍 코드
## 패리티 비트
* 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.
* 전송하고자하는 데이터의 각 문자에 1비트를 더하여 전송한다.
* 종류
  * 짝수(1의 개수가 모두 짝수가 되도록 패리티 비트를 정하는 것)
  * 홀수(1의 개수가 모두 홀수가 되도록 패리티 비트를 정하는 것)
* 전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것이다.
<br/>

### 짝수 패리티일 때 7비트 데이터가 1010001라면?
1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 한다.
답: 11010001(맨앞이 패리티비트)

<br/>

### 결론
* 이렇게 패리티 비트를 정하여 데이터를 보내면 받는 쪽에서는 수신된 데이터의 전체 비트를 계산하여 패리티 비트를 다시 계산함으로써 데이터 오류 발생 여부를 알 수 있다.
* 다만 패리티 비트는 오류 발생 여부만 알 수 있지 오류를 수정할 수는 없다는 단점이 있다.
* 따라서 통신을 하면서 데이터가 손실되어 패리티에 의한 데이터 손실이 발생함을 인지하였을 때에는 수신지에서 다시 데이터를 보내달라는 재송신 요청을 할 수 있도록 하는 보다 안정적인 통신을 위한 하나의 보호장치라 할 수 있다.

<br/>

## 해밍코드
* 데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드를 말한다.
* 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다.(패리티비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)

### 방법
2의 n승 번째 자리인 1,2,4 번째 자릿수가 패리티 비트라는 것으로부터 시작한다.
<br/>
이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.

<br/>

### 짝수 패리티의 해밍 코드가 01010101일때 오류가 수정된 코드는?
* 체크 비트는 2^0, 2^1, 2^2으로 증가하는 식
* 각 체크비트가 검사하는 데이터 비트는 자기자신을 포함하고 체크 비트의 값만큼 검사한다. 그리고 다시 체크 비트의 값만큼 데이터 비트를 뛰고 다시 검사하는 방식
* 예를 들어, 2^0 체크 비트는 첫 번째, 세 번째, 5번 째 등을 검사 / 2^1 체크 비트는 (두 번째, 세 번째), (여섯 번째, 일곱 번째) 등을 검사...

패리티 비트를 추가한 원래 넘어오는 값은 010100101111인데 만약 D9에서 에러가 발생했다고 가정하면 0100101011110이 된다. 체크비트만 모아놓으면, 0111이 수신되어야 하는데 1110이 수신된 것
이 둘을 XOR 처리하면 에러코드는 1001이고, 이를 10진수로 바꾸면 D9에 문제가 있다는 것을 확인할 수 있다.

![](https://mblogthumb-phinf.pstatic.net/MjAxNzExMDJfMjI0/MDAxNTA5NTk3NTY2ODMx.Wfw4JOlCFMqHLrBREq8QWJz2HvVY6mJSodoid3cLmHcg._a36a7wukjxCGcNroaFRtcB4mI2MpJ3U-_oz1cpv5icg.JPEG.ggggamang/1.JPG?type=w800)

<br/>

**[참조]**
* [원본링크](https://gyoogle.dev/blog/computer-science/computer-architecture/%ED%8C%A8%EB%A6%AC%ED%8B%B0%20%EB%B9%84%ED%8A%B8%20&%20%ED%95%B4%EB%B0%8D%20%EC%BD%94%EB%93%9C.html)
* [패리티비트](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ansdbtls4067&logNo=220886661657)
* [해임코드](https://m.blog.naver.com/ggggamang/221113176831)